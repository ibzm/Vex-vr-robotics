{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nimport math\nimport random\nfrom vexcode_vr import *\n\n# Brain defined by default\nbrain=Brain()\n\ndrivetrain = Drivetrain(\"drivetrain\", 0)\npen = Pen(\"pen\", 8)\npen.set_pen_width(THIN)\nleft_bumper = Bumper(\"leftBumper\", 2)\nright_bumper = Bumper(\"rightBumper\", 3)\nfront_eye = EyeSensor(\"frontEye\", 4)\ndown_eye = EyeSensor(\"downEye\", 5)\nfront_distance = Distance(\"frontdistance\", 6)\ndistance = front_distance\nmagnet = Electromagnet(\"magnet\", 7)\nlocation = Location(\"location\", 9)\n\n \n#1.Algorithm setup and memory\ncurrent_x = 0\ncurrent_y = 0\nheading = 0 # 0: North, 1: East, 2: South, 3: West\n\n# We use an Adjacency List instead of a 2D array to save memory. \n# We only map the open paths we actually drive on.  \n# If a coordinate isn't in this dictionary, the algorithm mathematically knows it's a wall\ngraph = {}  \n\n#Map and pathfidning function\n\ndef get_next_coord(x, y, h):\n    # Basic math to figure out the grid coordinates of the tile we are looking at\n    if h == 0: return (x, y + 1)\n    if h == 1: return (x + 1, y)\n    if h == 2: return (x, y - 1)\n    if h == 3: return (x - 1, y)\n\ndef add_edge(node1, node2):\n    # links two coordinates in our graph memory. \n    # This builds the map of safe, explorable connections.\n    if node1 not in graph: graph[node1] = []\n    if node2 not in graph: graph[node2] = []\n    if node2 not in graph[node1]: graph[node1].append(node2)\n    if node1 not in graph[node2]: graph[node2].append(node1)\n\ndef bfs_shortest_path(start, goal):\n    # This is Breadth-First Search (BFS). Since our grid has no weights\n    # every tile takes the same time to cross, BFS mathematically guarantees \n    # the absolute shortest route through our mapped paths, trimming out all the dead ends.\n    queue = [[start]]\n    visited = [] \n    while queue:\n        path = queue.pop(0)\n        node = path[-1]\n        if node == goal: \n            return path\n        if node not in visited:\n            visited.append(node)\n            for neighbor in graph.get(node, []):\n                new_path = list(path)\n                new_path.append(neighbor)\n                queue.append(new_path)\n    return []\n\ndef print_maze_to_console(exit_x, exit_y):\n    # Prints the Adjacency List visually so you can see the final maze layout.\n    brain.new_line()\n    brain.print(\"--- FINAL MAZE MAP ---\")\n    brain.new_line()\n    if not graph: return\n    \n    # Because im using a adjacency list instead of 2d array the robot dosent know \n    # how big the maze is so these lines scan the furthest north, south, west and east tiles\n    # we stepped on so when we print the map its only the box containing our path not empty space\n    min_x = min([p[0] for p in graph.keys()] + [0, exit_x])\n    max_x = max([p[0] for p in graph.keys()] + [0, exit_x])\n    min_y = min([p[1] for p in graph.keys()] + [0, exit_y])\n    max_y = max([p[1] for p in graph.keys()] + [0, exit_y])\n    \n    # Print top-down using 3 characters per tile for a wider, easier to read shape\n    for y in range(max_y, min_y - 1, -1):\n        row_str = \"\"\n        for x in range(min_x, max_x + 1):\n            if x == 0 and y == 0: row_str += \"[S]\" # Start\n            elif x == exit_x and y == exit_y: row_str += \"[E]\" # Exit\n            elif (x, y) in graph: row_str += \" . \" # Open path\n            else: row_str += \" # \" # Wall / Unvisited\n        brain.print(row_str)\n        brain.new_line()\n        \n    brain.print(\"----------------------\")\n    brain.new_line()\n    brain.new_line()\n\ndef main():\n    global current_x, current_y, heading, graph\n    \n    brain.clear()\n    brain.print(\"starting\")\n    brain.new_line()\n    #setting the pen to black\n    pen.move(DOWN)\n    pen.set_pen_color(BLACK)\n    drivetrain.set_drive_velocity(100, PERCENT)\n    drivetrain.set_turn_velocity(100, PERCENT)\n    #setting speed and turn rate\n\n    # PHASE 1: Explore the map\n   \n    brain.print(\"mapping the maze\")\n    brain.new_line()\n    \n    # We use the Right-Hand Rule to explore the maze.\n    # Trade-off: It explores super fast but only finds the shortest known path, \n    # not necessarily the global shortest path if a left-hand shortcut exists. \n    # This prioritizes speed over wasting battery mapping useless dead ends.\n    # Also in this maze their is only one way to get to the exit \n    while not down_eye.detect(RED):\n        drivetrain.turn_for(RIGHT, 90, DEGREES)\n        heading = (heading + 1) % 4\n        \n        # Check distance before moving so we never clip through a wall\n        if front_distance.get_distance(MM) > 250:\n            nxt = get_next_coord(current_x, current_y, heading)   # Calculate next tile\n            add_edge((current_x, current_y), nxt)                 # Save it to memory\n            drivetrain.drive_for(FORWARD, 250, MM)                # Drive safely\n            current_x, current_y = nxt                            # Update our position\n        else:\n            drivetrain.turn_for(LEFT, 90, DEGREES)\n            heading = (heading - 1) % 4\n            if front_distance.get_distance(MM) > 250:\n                nxt = get_next_coord(current_x, current_y, heading)   # Try straight\n                add_edge((current_x, current_y), nxt)\n                drivetrain.drive_for(FORWARD, 250, MM)\n                current_x, current_y = nxt\n            else:\n                drivetrain.turn_for(LEFT, 90, DEGREES)\n                heading = (heading - 1) % 4\n                if front_distance.get_distance(MM) > 250:\n                    nxt = get_next_coord(current_x, current_y, heading)   # Try left\n                    add_edge((current_x, current_y), nxt)\n                    drivetrain.drive_for(FORWARD, 250, MM)\n                    current_x, current_y = nxt\n                else:\n                    drivetrain.turn_for(LEFT, 90, DEGREES)\n                    heading = (heading - 1) % 4   # Dead end: Turn completely around\n\n    # Save the exit coordinates so we know where to drive back to\n    exit_x, exit_y = current_x, current_y\n    drivetrain.stop()\n    #just prints where the exit was found exactly\n    brain.print(\"exit found at: (\" + str(exit_x) + \", \" + str(exit_y) + \")\")\n    brain.new_line()\n    \n    # Show the stored Adjacency List map(the maze)\n    print_maze_to_console(exit_x, exit_y)\n\n    # PHASE 2: Return to start\n    # Run BFS to get the perfect path back, skipping the dead ends we explored\n    path_back_to_start = bfs_shortest_path((current_x, current_y), (0,0))\n    brain.print(\"return to start(shortest path)\")\n    brain.new_line()\n    pen.move(UP) # Lift pen so we don't mess up the map\n    follow_path(path_back_to_start)\n    \n    # PHASE 3: Draw shortest path to exit \n    # Now that we are back at the start draw the quickest route in Green to show it works\n    brain.print(\"shortest path to exit\")\n    brain.new_line()\n    path_to_exit = bfs_shortest_path((0,0), (exit_x, exit_y))\n    \n    pen.set_pen_color(GREEN)\n    pen.move(DOWN) # Put the pen back down\n    follow_path(path_to_exit)\n\n    drivetrain.stop()\n    brain.print(\"maze mapped finished\")\n    brain.new_line()\n\ndef follow_path(path_list):\n    # Takes the list of coordinates generated by BFS and translates \n    # it into actual robot turns and 250mm forward drives.\n    global heading, current_x, current_y\n    if len(path_list) <= 1: return\n    \n    for i in range(1, len(path_list)):\n        nxt = path_list[i]\n        # Figure out which way we need to face to get to the next tile (0=N, 1=E, 2=S, 3=W)\n        req_h = 0\n        if nxt[1] > current_y: req_h = 0\n        elif nxt[0] > current_x: req_h = 1\n        elif nxt[1] < current_y: req_h = 2\n        elif nxt[0] < current_x: req_h = 3\n        \n        # heading is where we are currently facing \n        # example math Facing West (3), Need to go North (0). \n        # (0 - 3) = -3.   -3 % 4 = 1.\n        # diff = 1, so the robot turns right 90 degrees!\n        diff = (req_h - heading) % 4\n        \n        if diff == 1:\n            drivetrain.turn_for(RIGHT, 90, DEGREES)   # 1 = One right turn.\n        elif diff == 2:\n            drivetrain.turn_for(RIGHT, 180, DEGREES)  # 2 = Turn around (180).\n        elif diff == 3:\n            drivetrain.turn_for(LEFT, 90, DEGREES)    # 3 = Three right turns (aka one left turn).\n            \n        heading = req_h\n        drivetrain.drive_for(FORWARD, 250, MM)\n        current_x, current_y = nxt\n\nvr_thread(main)","textLanguage":"python","robotConfig":[],"slot":0,"platform":"PG","sdkVersion":"20240802.15.00.00","appVersion":"4.63.0","minVersion":"4.60.0","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false,"aiVisionSettings":{"colors":[],"codes":[],"tags":true,"AIObjects":true,"AIObjectModel":[],"aiModelDropDownValue":null},"playground":"DynamicWallMaze","robotModel":"vr"}